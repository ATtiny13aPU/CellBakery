#version 430

layout (local_size_x = 1, local_size_y = 1, local_size_z = 1) in;

uniform int Dm;
uniform float Ac;

const int nullID = 0x7FFFFFFF;

struct Cell {
	vec2 pos;
	float radius;
	float angle;
	vec3 color_rgb;
	vec3 color_hsv;
	int type_id;
	int linked_list;
	int chank_id;
	int is_first;
};

restrict buffer ssbo_cells {
    Cell cells[];
};

struct Chunk {
	int linked_list;
	float brightness;
};

restrict buffer ssbo_grid {
    Chunk chunks[];
};

mat2 rot(float a) { //матрица поворота по заданному углу
	float s = sin(a);
	float c = cos(a);
	return mat2(c, -s, s, c);
}

/*
// Рабочий однопоточный вариант. 
// Нельзя запускать без изменения glDispatchCompute(8, 8, world.mec / 1024); на glDispatchCompute(1, 1, 1); на CPU
void main() {
	int workGroupID = int(gl_GlobalInvocationID.x * 16 + gl_GlobalInvocationID.y * 128 + gl_GlobalInvocationID.z * 1024);
	
	for (int cid = 0; cid < 1024; cid++) {
		cells[cid].chank_id = int(cells[cid].pos.x / Ac) + int(cells[cid].pos.y / Ac) * Dm;
		cells[cid].linked_list = 0;
		cells[cid].is_first = 0;
	}

	for (int cid = 0; cid < 1024; cid++)
		chunks[cells[cid].chank_id].linked_list = nullID;

	// строим связный список
	for (int cid = 0; cid < 1024; cid++) {
		int tid = chunks[cells[cid].chank_id].linked_list;
		chunks[cells[cid].chank_id].linked_list = cid;
		cells[cid].linked_list = tid;
		if (tid == nullID)
			chunks[cells[cid].chank_id].brightness += 0.4;
	}

	for (int cid = 0; cid < 1024; cid++)
		chunks[cells[cid].chank_id].linked_list = nullID;

	return;
}
*/


void main() {
	int workGroupID = int(gl_GlobalInvocationID.x * 16 + gl_GlobalInvocationID.y * 128 + gl_GlobalInvocationID.z * 1024);
	
	for (int cid = workGroupID; cid < workGroupID + 16; cid++) {
		cells[cid].chank_id = int(cells[cid].pos.x / Ac) + int(cells[cid].pos.y / Ac) * Dm;
		cells[cid].linked_list = 0;
		cells[cid].is_first = 0;
	}

	for (int cid = workGroupID; cid < workGroupID + 16; cid++)
		chunks[cells[cid].chank_id].linked_list = nullID;

	memoryBarrierShared();
	barrier();

	// строим связный список
	for (int cid = workGroupID; cid < workGroupID + 16; cid++) {
		int tid = cid;
		tid = atomicExchange(chunks[cells[cid].chank_id].linked_list, tid);

		cells[cid].linked_list = tid;
		if (tid == nullID)
			chunks[cells[cid].chank_id].brightness += 0.4;
	//	if (tid != nullID)
	//		cells[tid].is_first = 0;
	}

	memoryBarrierShared();
	barrier();

//	// старшие клетки в списке ставят метку на карте
//	for (uint cid = workGroupID; cid < workGroupID  + 16; cid++)
//		if (cells[cid].is_first == 1)
//			chunks[cells[cid].chank_id].brightness += 0.4;

	//cells[cid].pos += vec2(.00002, 0.) * rot(cells[cid].angle * 3.14159265358 * 2.);

	for (int cid = workGroupID; cid < workGroupID  + 16; cid++)
		chunks[cells[cid].chank_id].linked_list = nullID;

	return;
}
